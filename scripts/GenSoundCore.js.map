{"version":3,"sources":["../GenSound/GenSoundCore.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,kCAGa,EAHb;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAQ2G;AAAA,0BAApD,mBAAsB;AAAA;AAAA,SAAtB,EAAxB,iCAAwB,CAAoD;AAAW;;AAM9G;AAAS;;AACH;AADN,eAKD,oBAAuB;AAAA;AAAA,SAAvB,EADA;AAAA;AAAA,SAFH,CACG,uBADH,oBAAU;AAAA;AAAA,SAAV,aACG,CADH,CAGG,CALC;AAAM;;AASV;AAAA,wBAAC,IAAK,cAAL,oBAAD,UAA0C,4BAAiB,EAAE,SAAC,OAAD,QAAiB,IAAK,cAAtB,CAAF,CAAjB,CAA1C;AAA4F;;AAC5E;AAAA,oBAAK,IAAM,SAAI,MAAJ,CAAX;AAAuB;;AAEpB;AAAA,oBAAK,IAAQ,SAAC,IAAQ,OAAR,OAAQ,OAAT,IAAR,OAAQ,SAAC,IAAQ,OAAR,OAAQ,OAAT,IAAb;AAAuC;;AAEtD;AAEI;AAAA;AAAA;AAAgB,8DAAC,2EAAwD,mDAAxD,CAAD;;AACsB,gEACa;AAAW,gDAAK,eAAL;AAAX;AAAQ,qBADrB;;AAGJ,4DAAiB;AAAA,yDAvBzC,CAAE,oCAAD,mCAAD,oCAuByC;AAAA,qBAAjB;;AAS/B,yDAHA,0BACK;AAAO,8CAAW,qCAAX;;AACX,4BAAG,WAAW,cAAd;AAAA;AAAA,+BAAwC;AAAA,4CAA4D,SAAR,IAAX,OAA/B,wBAA+B,CAAmB,CAA5D;AAAgE;AADhG,qBADT,EAHA,0BACM;AAAO;;AACX,4BAAG,iBAAW,kBAAd;AAAA;AAAA,+BAA4C;AAAA,4CAAU,eAAuB,cAAP,YAAhB,CAAV;AAA8D;AADlG,qBADV,EADH,oBAAS;AAAA;AAAA,qBAAT,sBAAmD,mBAAkB;AAAA;AAAA,qBAAlB,iBAAnD,CACG,CAGA,CAGA;AACU;AAdb;AAAa,iBAAb;AAAA;AAAA;;AAmBH,sCAAW,kCAAX,EAAsB,kCAAtB;AAME,kCAAQ;AAAA;AAAA,SAAR,EAHA,oBACK;AAAO,gDAAqB,cAArB;AAAP,oBACH,eAAU,SAAK,mBAAL,CAAV,IADG;AAAI,SADT,2BAGA;AA3BuC;;AA8B9C;AACI;AAAA;AAAA,uBAAG,yBAAH,GAA+B,4BAA/B,GAGW,oBAAmB;AAAA;AAAA,iBAAnB,EADA;AAAA;AAAA,mBADN,8BAAsB;AAAA,wCAAc,2BAAd;AAAA,iBAAtB,CACM,CACA,CAHX;AAAA;AAAA;;AAI8D;AAAA;AAAA,WAAlE,mCAA2B;AAAA;AAAA,SAA3B,CAAkE;AAAe;;;;AAMjF;AAAA,sCAA8B,gBAAsB;AAAA,uBA1DlC,CAAE,iBAAD,aAAD,cA0DkC,IAA2B,KAAM,qBAAjC;AAAA,SAAtB,CAA9B;AAAyG;;AArE7G,gDAuEoB,oHAvEpB;AAAA,gCA4EY,mBA5EZ;AAAA;AAAA;;AAAA,kCAgF6E;AAAA;AAAA,KAAhE,CAAoC;AAAA;AAAA,OAApC,mCAAoC,CAApC,CAhFb;;AAAA,wBAkFQ,aAlFR","file":"GenSoundCore.js","sourceRoot":"C:/Users/exyi/Source/Repos/GenSound/scripts","sourcesContent":["﻿module GenSoundCore\r\nopen Fable.Core\r\n\r\nlet random = new System.Random()\r\n[<Emit(\"Math.random()\")>]\r\nlet randomReal () = random.NextDouble()\r\ntype ScaleSettings  = { IntervalWeights: float array; ToneWeights: float array}\r\ntype Note = { Length: float; Notes: int array }\r\nlet createNotes rythm melody = Seq.zip melody rythm |> Seq.map (fun (m,r) -> { Length = r; Notes = m }) |> Seq.toArray\r\n\r\n\r\nlet inline (%%) n m = ((n % m) + m) % m\r\n\r\nlet pickRandom weights elements =\r\n    let totalW = Seq.sum weights\r\n    let num = randomReal ()  * totalW\r\n    Seq.scan (+) 0. weights // accumulate weights by (+)\r\n    |> Seq.skip 1\r\n    |> Seq.zip elements\r\n    |> Seq.find(fun (e, w) -> w > num) // get first with accumulate weight > num\r\n    |> fst\r\n\r\nlet normalDistribution μ σ x =\r\n    (2. * σ ** 2. * System.Math.PI) ** -0.5 * System.Math.E ** -((x - μ) ** 2. / (2. * σ ** 2.))\r\nlet sigmoid value = 1.0/(1.0 + exp(-value))\r\n\r\nlet toneReturnCoef x = 1. - min 1. ((max 0. (x - 0.4)) ** 2.0) // reduce probability of going too far from origin, p = 1 for 0 dist, p > 0.95 for 0.6 range, p ~= 0.7 for 1 range\r\nlet getMelody rythm scaleSettings toneRange =\r\n    let chooseTone previous toneImportance jumpBar =\r\n\r\n        let possibleTones = [-scaleSettings.IntervalWeights.Length + 1 + previous .. scaleSettings.IntervalWeights.Length - 1 + previous]\r\n        let allIntervalWeights = possibleTones |> Seq.map (fun tone ->\r\n                                                           let interval = abs (tone - previous)\r\n                                                           scaleSettings.IntervalWeights.[interval])\r\n        let allToneWeights = possibleTones |> Seq.map(fun i -> scaleSettings.ToneWeights.[i %% scaleSettings.ToneWeights.Length])\r\n        let totalWeights = \r\n            Seq.map2 (*) allIntervalWeights (allToneWeights |> Seq.map (fun x -> x ** toneImportance)) // multiply w_tone with w_interval, power to toneImportance\r\n            |> Seq.mapi (fun i weight ->\r\n                 let tone = possibleTones.[i]\r\n                 if abs tone < abs previous then weight else weight * (toneReturnCoef (float (abs tone) / float toneRange))) // reduce probability of going too far from origin\r\n            |> Seq.mapi (fun i weight ->\r\n                let tone = previous - possibleTones.[i]\r\n                if jumpBar >= abs tone then weight else weight / (abs tone - jumpBar |> float |> (*)0.1 |> (+)1. |> exp)) // reduce probability of jumps over jumpbar\r\n            |> Seq.toArray\r\n        let resultTone = pickRandom totalWeights possibleTones\r\n        // TODO: introduce interval\r\n        resultTone\r\n\r\n    let startingTone = \r\n         pickRandom [1.;1.;1.] [0;2;4] // reimplementation\r\n//        chooseTone 0 5.0 10\r\n    rythm \r\n        |> Seq.scan (fun (jumpBar, previous) toneLength ->\r\n            let next = chooseTone previous (1. + toneLength) jumpBar\r\n            (jumpBar - abs (next - previous) + 4, next)) (2, startingTone)\r\n        |> Seq.map snd\r\n\r\nlet getRythm divCoef recursionCoef length =\r\n    let rec getTactRythm divCoef recursionCoef =\r\n        if randomReal() > divCoef then [1.0]\r\n        else List.init 2 (fun i -> getTactRythm (divCoef/recursionCoef) recursionCoef) // recurse to two tacts\r\n                |> List.collect id // collect them to one list\r\n                |> List.map (fun l -> l / 2.0) // divide length by 2\r\n    List.init length (fun i -> getTactRythm divCoef recursionCoef) |> List.collect id\r\n\r\nlet detectHarmony (melody: Note seq) scaleSettings =\r\n    ()\r\n\r\nlet convertTone (key: int array) {Length=len; Notes=notes} =\r\n    {Length=len; Notes = notes |> Array.map(fun tone -> key.[tone %% key.Length] + 12 * (tone / key.Length))}\r\n\r\nlet scaleSettings = {\r\n    IntervalWeights = [| 1.0; 5.0; 5.0; 3.0; 3.0; 0.7; 0.7; 1.0 |]\r\n    ToneWeights =     [| 1.7; 1.5; 1.6; 1.0; 1.6; 1.5; 1.0 |]\r\n    } \r\n\r\nlet rythm = getRythm 4.0 2.9 3\r\nlet cMajor = [|0;2;4;5;7;9;11|]\r\nlet cMinor = [|0;2;3;5;7;8;10|]\r\n\r\nlet melody = getMelody rythm scaleSettings 20 |> Seq.map (fun x -> [|x|]) |> createNotes rythm\r\n\r\nlet x = max 2 1"]}